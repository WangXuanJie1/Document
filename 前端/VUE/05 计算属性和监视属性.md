## comuted和watch
1. 计算属性用于根据依赖的响应式数据进行计算并返回一个新的值。
2. 而监视属性用于监听某个特定的响应式数据的变化，并在数据变化时执行一些自定义的逻辑。

```js
computed: {
  doubledCount() {
    return this.count * 2;
  }
}

watch: {
  count(newValue, oldValue) {
    console.log(`count 发生变化，新值为 ${newValue}，旧值为 ${oldValue}`);
  }
}

```

## 计算属性的底层实现原理，依赖追踪和缓存机制
1. 当一个计算属性被定义时，Vue.js 会将它转换为一个 getter 函数，并将这个函数作为该属性的访问器（getter）添加到组件实例上。在模板中使用计算属性时，实际上是调用了这个 getter 函数来获取计算得到的值
2. 在计算属性的 getter 函数内部，Vue.js 将开始进行依赖追踪。当访问计算属性时，Vue.js 会记录当前正在执行的计算属性，并将它添加到一个依赖收集器中。同时，计算属性会依赖于它所访问的其他响应式数据。
3. 当依赖的响应式数据发生变化时，Vue.js 会通知依赖收集器，以便重新计算相关的计算属性。此时，Vue.js 会重新执行计算属性的 getter 函数，并将其结果缓存起来。
4. Vue.js 将直接返回缓存的计算结果，而不会再次重新计算。只有当计算属性的依赖发生变化时，才会重新计算计算属性并更新缓存。（只有当依赖更新的时候才会重新计算）
5. 当响应式数据发生变化时，Vue.js 会触发更新操作，包括计算属性的重新计算和通知相关的组件进行更新。这样就能保证页面上的数据和视图都是最新的。

## 简述属性的底层实现原理
1. 当一个监视属性被定义时，Vue.js 会将它转换为一个 watcher 实例，并将这个 watcher 实例添加到组件实例上。监视属性需要指定一个要监视的响应式数据，并提供一个回调函数，在监视的数据变化时执行该回调函数。
2. Vue.js会创建一个 watcher 实例，并将其关联到要监视的响应式数据上。当监视的响应式数据发生变化时，Vue.js会通知关联的 watcher 实例去执行相应的逻辑。
3. Watcher 实例内部会维护一个队列，用于存储需要执行的回调函数。当监视的响应式数据发生变化时，Watcher 实例会将回调函数添加到队列中。
4. Vue.js 使用了异步更新策略来优化性能。这意味着只要监视的响应式数据发生变化，Vue.js 就会将回调函数推入到队列中，而不是立即执行它们。这样可以避免在同一个事件循环中多次执行相同的回调函数，提高了性能和效率。
