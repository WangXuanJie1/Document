#### MySQL Server架构自顶向下大致可以分网络连接层、服务层、存储引擎层和系统文件层。
### 网络连接层 
1. 客户端连接器（Client Connectors）：提供与MySQL服务器建立的支持。目前几乎支持所有主流的服务端编程技术，例如常见的 Java、C、Python、.NET等，它们通过各自API技术与MySQL建立

### 服务层（MySQL Server） 服务层是MySQL Server的核心，主要包含系统管理和控制工具、连接池、SQL接口、解析器、查询优 化器和缓存六个部分。
1. 连接池（Connection Pool）：负责存储和管理客户端与数据库的连接，一个线程负责管理一个 连接。
2. 系统管理和控制工具（Management Services & Utilities）：例如备份恢复、安全管理、集群管理等
3. SQL接口（SQL Interface）：用于接受客户端发送的各种SQL命令，并且返回用户需要查询的结 果。比如DML、DDL、存储过程、视图、触发器等。
4. 解析器（Parser）：负责将请求的SQL解析生成一个"解析树"。然后根据一些MySQL规则进一步 检查解析树是否合法。
5. 查询优化器（Optimizer）：当“解析树”通过解析器语法检查后，将交由优化器将其转化成执行计 划，然后与存储引擎交互。 select uid,name from user where gender=1; 选取--》投影--》联接 策略 1）select先根据where语句进行选取，并不是查询出全部数据再过滤 2）select查询根据uid和name进行属性投影，并不是取出所有字段 3）将前面选取和投影联接起来最终生成查询结果
6. 缓存（Cache&Buffer）： 缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，权限缓存，引擎缓存等。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。

### 存储引擎层（Pluggable Storage Engines） 存储引擎负责MySQL中数据的存储与提取，与底层系统文件进行交互。MySQL存储引擎是插件式的， 服务器中的查询执行引擎通过接口与存储引擎进行通信，接口屏蔽了不同存储引擎之间的差异 。现在有
很多种存储引擎，各有各的特点，最常见的是MyISAM和InnoDB。

### 系统文件层（File System）
1. 日志文件 错误日志（Error log） 默认开启，show variables like '%log_error%'
2. 通用查询日志（General query log） 记录一般查询语句，show variables like '%general%';
3. 二进制日志（binary log） 记录了对MySQL数据库执行的更改操作，并且记录了语句的发生时间、执行时长；但是它不 记录select、show等不修改数据库的SQL。主要用于数据库恢复和主从复制。 show variables like '%log_bin%'; //是否开启 show variables like '%binlog%'; //参数查看 show binary logs;//查看日志文件
4. 慢查询日志（Slow query log）记录所有执行时间超时的查询SQL，默认是10秒。 show variables like '%slow_query%'; //是否开启show variables like '%long_query_time%'; //时长
5. 配置文件 用于存放MySQL所有的配置信息文件，比如my.cnf、my.ini等。
6. 数据文件
7. pid 文件 pid 文件是 mysqld 应用程序在 Unix/Linux 环境下的一个进程文件，和许多其他 Unix/Linux 服务端程序一样，它存放着自己的进程 id。
8. socket 文件 socket 文件也是在 Unix/Linux 环境下才有的，用户在 Unix/Linux 环境下客户端连接可以不通过TCP/IP 网络而直接使用 Unix Socket 来连接 MySQL。

### MySQL运行机制
1. 建立连接
2. 查询缓存
3. 解析器
4. 查询优化器
5. 查询执行引擎负责执行sql

### InnoDB存储结构
从MySQL 5.5版本开始默认使用InnoDB作为引擎，它擅长处理事务，具有自动崩溃恢复的特性，在日 常开发中使用非常广泛。下面是官方的InnoDB引擎架构图，主要分为内存结构和磁盘结构两大部分。
内存结构主要包括Buffer Pool、Change Buffer、Adaptive Hash Index和Log Buffer四大组件。

#### Buffer Pool：缓冲池，简称BP。BP以Page页为单位，默认大小16K，BP的底层采用链表数 据结构管理Page。在InnoDB访问表记录和索引时会在Page页中缓存，以后使用可以减少磁盘IO操作，提升效率。
1. BP以Page页为单位，默认大小16K，BP的底层采用链表数据结构管理Page。在InnoDB访问表记录和索引时会在Page页中缓存，以后使用可以减少磁盘IO操作，提升效率。
2.  Page管理机制 Page根据状态可以分为三种类型： free page ： 空闲page，未被使用clean page：被使用page，数据没有被修改过
3. 针对上述三种page类型，InnoDB通过三种链表结构来维护和管理 free list ：表示空闲缓冲区，管理free page
4. flush list：表示需要刷新到磁盘的缓冲区，管理dirty page，内部page按修改时间 排序。脏页即存在于flush链表，也在LRU链表中，但是两种互不影响，LRU链表负 责管理page的可用性和释放，而flush链表负责管理脏页的刷盘操作。
5. lru list：表示正在使用的缓冲区，管理clean page和dirty page，缓冲区以 midpoint为基点，前面链表称为new列表区，存放经常访问的数据，占63%；后 面的链表称为old列表区，存放使用较少数据，占37%。
6. 改进型LRU算法维护普通LRU：末尾淘汰法，新数据从链表头部加入，释放空间时从末尾淘汰改性LRU：链表分为new和old两个部分，加入元素时并不是从表头插入，而是从中间 midpoint位置插入，如果数据很快被访问，那么page就会向new列表头部移动，如果 数据没有被访问，会逐步向old尾部移动，等待淘汰。
7. 每当有新的page数据读取到buffer pool时，InnoDb引擎会判断是否有空闲页，是否足够，如果有就将free page从free list列表删除，放入到LRU列表中。没有空闲页，就会根据LRU算法淘汰LRU链表默认的页，将内存空间释放分配给新的页。
8. Buffer Pool配置参数 show variables like '%innodb_page_size%'; //查看page页大小 show variables like '%innodb_old%'; //查看lru list中old列表参数 show variables like '%innodb_buffer%'; //查看buffer pool参数 建议：将innodb_buffer_pool_size设置为总内存大小的60%-80%，
innodb_buffer_pool_instances可以设置为多个，这样可以避免缓存争夺

#### Change Buffer：写缓冲区
1. 简称CB。在进行DML操作时，如果BP没有其相应的Page数据， 并不会立刻将磁盘页加载到缓冲池，而是在CB记录缓冲变更，等未来数据被读取时，再将数据合并恢复到BP中
2. ChangeBuffer占用BufferPool空间，默认占25%，最大允许占50%，可以根据读写业务量来 进行调整。参数innodb_change_buffer_max_size;
3. 当更新一条记录时，该记录在BufferPool存在，直接在BufferPool修改，一次内存操作。如 果该记录在BufferPool不存在（没有命中），会直接在ChangeBuffer进行一次内存操作，不 用再去磁盘查询数据，避免一次磁盘IO。当下次查询记录时，会先进性磁盘读取，然后再从
ChangeBuffer中读取信息合并，最终载入BufferPool中。
4. 如果在索引设置唯一性，在进行修改时，InnoDB必须要做唯一性校验，因此必须查询磁盘， 做一次IO操作。会直接将记录查询到BufferPool中，然后在缓冲池修改，不会在
ChangeBuffer操作。

#### Adaptive Hash Index：自适应哈希索引
1. 用于优化对BP数据的查询。InnoDB存储引擎会监 控对表索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，所以称之为自适应。InnoDB存储引擎会自动根据访问的频率和模式来为某些页建立哈希索引。

#### Log Buffer：日志缓冲区，用来保存要写入磁盘上log文件（Redo/Undo）的数据，
1. 日志缓冲 区的内容定期刷新到磁盘log文件中。日志缓冲区满时会自动将其刷新到磁盘，当遇到BLOB或多行更新的大事务操作时，增加日志缓冲区可以节省磁盘I/O。
2. innodb_flush_log_at_trx_commit参数控制日志刷新行为，默认为1 0 ： 每隔1秒写日志文件和刷盘操作（写日志文件LogBuffer-->OS cache，刷盘OS cache-->磁盘文件），最多丢失1秒数据 1：事务提交，立刻写日志文件和刷盘，数据不丢失，但是会频繁IO操作
2：事务提交，立刻写日志文件，每隔1秒钟进行刷盘操作

#### innoDB磁盘结构
InnoDB磁盘主要包含Tablespaces，InnoDB Data Dictionary，Doublewrite Buffer、Redo Log 和Undo Logs


### 表空间（Tablespaces）：用于存储表结构和数据。表空间又分为系统表空间、独立表空间、 通用表空间、临时表空间、Undo表空间等多种类型；
1. 系统表空间（The System Tablespace） 包含InnoDB数据字典，Doublewrite Buffer，Change Buffer，Undo Logs的存储区域。系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。
2. 系统表空 间是一个共享的表空间因为它是被多个表共享的。该空间的数据文件通过参数 innodb_data_file_path控制，默认值是ibdata1:12M:autoextend(文件名为ibdata1、12MB、自动扩展)。
3. 独立表空间（File-Per-Table Tablespaces） 默认开启，独立表空间是一个单表表空间，该表创建于自己的数据文件中，而非创建于系统表空间中。当innodb_file_per_table选项开启时，表将被创建于表空间中。
4. 否则， innodb将被创建于系统表空间中。每个表文件表空间由一个.ibd数据文件代表，该文件 默认被创建于数据库目录中。表空间的表文件支持动态（dynamic）和压缩
5. 通用表空间（General Tablespaces） 通用表空间为通过create tablespace语法创建的共享表空间。通用表空间可以创建于mysql数据目录外的其他表空间，其可以容纳多张表，且其支持所有的行格式。
6. 撤销表空间（Undo Tablespaces）
7. 临时表空间（Temporary Tablespaces）
8. 数据字典（InnoDB Data Dictionary）
9. 双写缓冲区（Doublewrite Buffer）
10. 重做日志（Redo Log）
11. 撤销日志（Undo Logs）

MySQL 5.7 版本 将 Undo日志表空间从共享表空间 ibdata 文件中分离出来，可以在安装 MySQL 时由用 户自行指定文件大小和数量。 增加了 temporary 临时表空间，里面存储着临时表或临时查询结果集的数据。 Buffer Pool 大小可以动态修改，无需重启数据库实例。
MySQL 8.0 版本 将InnoDB表的数据字典和Undo都从共享表空间ibdata中彻底分离出来了，以前需要 ibdata中数据字典与独立表空间ibd文件中数据字典一致才行，8.0版本就不需要了。 temporary 临时表空间也可以配置多个物理文件，而且均为 InnoDB 存储引擎并能创建 索引，这样加快了处理的速度。 用户可以像 Oracle 数据库那样设置一些表空间，每个表空间对应多个物理文件，每个 表空间可以给多个表使用，但一个表只能存储在一个表空间中。
将Doublewrite Buffer从共享表空间ibdata中也分离出来了。

### InnoDB的表要求必须要有聚簇索引： 
1. 如果表定义了主键，则主键索引就是聚簇索引
2. 如果表没有定义主键，则第一个非空unique列作为聚簇索引
3. 否则InnoDB会从建一个隐藏的row-id作为聚簇索引

### 辅助索引
1. InnoDB辅助索引，也叫作二级索引，是根据索引列构建 B+Tree结构。但在 B+Tree 的叶子节点中 只存了索引列和主键的信息。二级索引占用的空间会比聚簇索引小很多， 通常创建辅助索引就是为了提升查询效率。一个表InnoDB只能创建一个聚簇索引，但可以创建多个辅助索引。
2. 辅助索引根据列做b+树，来快速查询你一个数据的位置值，然后根据聚簇索引找出元素的位置，查询信息

### 回表查询 
1. 在之前介绍过，InnoDB索引有聚簇索引和辅助索引。
2. 聚簇索引的叶子节点存储行记录，InnoDB必须要 有，且只有一个。辅助索引的叶子节点存储的是主键值和索引字段值，通过辅助索引无法直接定位行记录，通常情况下，需要扫码两遍索引树。
3. 先通过辅助索引定位主键值，然后再通过聚簇索引定位行记录，这就叫做回表查询，它的性能比扫一遍索引树低。总结：通过索引查询主键值，然后再去聚簇索引查询记录信息
   
###  索引与排序
MySQL查询支持filesort和index两种方式的排序，filesort是先把结果查出，然后在缓存或磁盘进行排序 操作，效率较低。使用index是指利用索引自动实现排序，不需另做排序操作，效率会比较高。
双路排序：需要两次磁盘扫描读取，最终得到用户数据。第一次将排序字段读取出来，然后排序；第二 次去读取其他字段数据。
单路排序：从磁盘查询所需的所有列数据，然后在内存排序将结果返回。如果查询数据超出缓存 sort_buffer，会导致多次磁盘读取操作，并创建临时表，最后产生了多次IO，反而会增加负担。解决方
案：少使用select *；增加sort_buffer_size容量和max_length_for_sort_data容量。

### 慢查询优化
1. 查看慢查询的基于，可以根据show.log文件还可以使用命名工具来查看
2. 查看是否使用索引，查看索引是否命中explain
3. 提高索引的过滤性，需要添加联合索引，覆盖索引
4. 分页查询优化，使用子查询，使用覆盖索引

### MVCC 并发控制中，读操作可以分为两类: 快照读（Snapshot Read）与当前读 （Current Read）。
1. 快照读：读取的是记录的快照版本（有可能是历史版本），不用加锁。（select）
2. 当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发修改这条记录。（select... for update 或lock in share mode，insert/delete/update）
3. 读读，读写，写读，都是可以通过并发控制实现的，但是select for update，还有写写需要使用乐观锁和悲观锁一起实现

### "IN SHARE MODE"和"SELECT FOR UPDATE"是MySQL中两种不同的锁定模式。

1. IN SHARE MODE：读取的时候，防止修改
   - 适用于读取操作，用于在读取数据时保持共享锁。
   - 允许多个会话并发读取相同的数据，但防止其他会话对这些数据进行修改。
   - 保持了读取的一致性，并避免了读取冲突。

2. SELECT FOR UPDATE：写入的时候，防止其他数据读取
   - 适用于写入操作，用于在读取数据时保持排他锁。
   - 阻止其他会话对这些数据进行读取或写入操作。
   - 确保在事务中对数据进行读取和修改的一致性，并避免并发冲突。
  
因此，主要区别在于锁定模式的适用场景和对并发操作的影响。"IN SHARE MODE"适用于读取操作，允许并发读取但禁止修改，而"SELECT FOR UPDATE"适用于写入操作，阻止其他会话对数据的读取和写入。

### 乐观锁和悲观锁
1. 乐观锁和悲观锁是在并发控制中常用的两种策略。
2. 悲观锁是一种较保守的策略，它假设在整个事务过程中会发生冲突，因此在对数据进行操作之前会先加锁。即使有多个事务同时访问某个数据，悲观锁也会将数据锁定，直到当前事务操作完成，其他事务才能继续对该数据进行操作。悲观锁保证了数据的安全性，但是并发性较差，因为其他事务需要等待锁的释放才能继续操作。
3. 乐观锁则是一种较乐观的策略，它认为在大多数情况下不会发生冲突，因此不会立即加锁。当事务进行操作时，它会先读取数据，并在执行更新操作之前检查该数据是否被其他事务修改过。如果没有被修改，就执行更新操作；如果被修改过，则放弃当前事务的更新操作。乐观锁适用于并发冲突较少的场景，可以提高并发性能，但是需要进行额外的检查和处理。
4. 在实际应用中，乐观锁通常通过版本号或时间戳等机制来实现。每次更新操作时，都会对数据的版本号进行更新，如果版本号与当前事务不一致，则说明数据已经被其他事务修改过。
5. 选择使用悲观锁还是乐观锁，取决于具体的业务场景和并发冲突的概率。悲观锁适用于并发冲突较多、数据安全性要求较高的场景，而乐观锁适用于并发冲突较少、对性能要求较高的场景。

### 事务的隔离级别
1. 读未提交 Read Uncommitted 读未提交：解决了回滚覆盖类型的更新丢失，但可能发生脏读现象，也就是 可能读取到其他会话中未提交事务修改的数据。 已提交读
2. Read Committed 读已提交：只能读取到其他会话中已经提交的数据，解决了脏读。但可能发生 不可重复读现象，也就是可能在一个事务中两次查询结果不一致。
3. 可重复度Repeatable Read 可重复读：解决了不可重复读，它确保同一事务的多个实例在并发读取数据 时，会看到同样的数据行。不过理论上会出现幻读，
4. 简单的说幻读指的的当用户读取某一范围的数 据行时，另一个事务又在该范围插入了新行，当用户在读取该范围的数据时会发现有新的幻影行。
5. 可串行化 Serializable 串行化：所有的增删改查串行执行。它通过强制事务排序，解决相互冲突，从而解决幻度的问题。这个级别可能导致大量的超时现象的和锁竞争，效率低下。

### 行锁原理其中行锁又分为共享锁和排他锁
1. RecordLock锁：锁定单个行记录的锁。（记录锁，RC、RR隔离级别都支持）
2. GapLock锁：间隙锁，锁定索引记录间隙，确保索引记录的间隙不变。（范围锁，RR隔离级别支 持）
3. Next-key Lock 锁：记录锁和间隙锁组合，同时锁住数据，并且锁住数据前后范围。（记录锁+范围锁，RR隔离级别支持）

### 主从复制
1. 实时灾备，用于故障切换（高可用）
2. 读写分离，提供查询服务（读扩展）
3. 数据备份，避免影响业务（高可用）
4. 从库服务器能连通主库 ，主库开启binlog日志（设置log-bin参数），主从server-id不同
5. 主从复制整体分为以下三个步骤：上述过程都是异步操作，俗称异步复制，存在数据延迟现象。
   - 主库将数据库的变更操作记录到Binlog日志文件中
   - 从库读取主库中的Binlog日志文件信息写入到从库的Relay Log中继日志中
   - 从库读取中继日志信息在从库中进行Replay,更新从库数据信息
### 主从复制的问题
1. mysql主从复制存在的问题： 主库宕机后，数据可能丢失 从库只有一个SQL Thread，主库写压力大，复制很可能延时
2. 半同步复制---解决数据丢失的问题，ack机制防止数据复制的时候丢失
3. 并行复制----解决从库复制延迟的问题，使用多线程机制减少从库的复制延迟

### 读写分离： 双主单写，MHA模式

### 分库分表
1. 垂直拆分：由于表数量多导致的单个库大。将表拆分到多个库中。（将表拆分到多个数据库中）
2. 水平拆分：由于表记录多导致的单个库大。将表记录拆分到多个表中。（将一张表拆分为多张表）
3. 水平拆分优点：
    - 拆分规则设计好，join 操作基本可以数据库做；
    - 不存在单库大数据，高并发的性能瓶颈；
    - 切分的表的结构相同，应用层改造较少，只需要增加路由规则即可； 提高了系统的稳定性和负载能力。
4. 水平拆分缺点：
    - 拆分规则难以抽象；
    - 跨库Join性能较差；
    - 分片事务的一致性难以解决；
    - 数据扩容的难度和维护量极大。
