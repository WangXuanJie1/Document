## 优化sql
1. 硬件和操作系统层面的优化：搭建mysql集群，设计读写分离。引入分库分表，针对热点数据做缓存
2. 架构设计的层面
3. mysql程序配置：修改最大连接数151
4. SQL优化：explain关键字执行计划，慢查询优化
  基于索引的数据扫描，避免索引上面的计算，where中like %尽量在右边，尽可能使用联合索引，查询有效列的集合少使用select*，小表驱动大表
  
## 分库分表
1. 水平分库：以字段为依据，按照一定策略（hash、range 等），将一个库中的数 据拆分到多个库中。
2. 水平分表：以字段为依据，按照一定策略（hash、range 等），将一个表中的数 据拆分到多个表中。
3. 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
4. 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和 扩展表）中。

## 分库分表中间件
harding-jdbc（当当）  Mycat  TDDL（淘宝）  Oceanus(58 同城数据库中间件)  vitess（谷歌开发的数据库中间件） Atlas(Qihoo 360)

## 分库分表存在的问题
1. 事务问题：需要用分布式事务啦  跨节点 
2. Join 的问题：解决这一问题可以分两次查询实现
3. 跨节点的 count,order by,group by 以及聚合函数问题：分别在各个节点上得到 结果后在应用程序端进行合并
4. 数据迁移，容量规划，扩容等问题
5. D问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单 可以考虑UUID

## 场景问题
1. **只分库不分表**：当数据库的读写访问量过高，还有可能会出现数据库连接不够用的情况。这个时候我们就需要 考虑分库，通过增加数据库实例的方式来获得更多的数据库连接，从而提升系统的并发性能。
2. **只分表不分库**： 当单表存储的数据量非常大的情况下，并且并发量也不高，数据库的连接也还够用。但是数据，写入和查询的性能出现了瓶颈，这个时候就需要考虑分表了。将数据拆分到多张表中来减少单表存储  的数据量，从而提升读写的效率
3. **又分库又分表**： 数据库访问量很大，或者是数据量大

## InnoDB 与MyISAM 的区别
1. 在Mysql 5.5之前，默认的存储引擎是MyISAM，从5.5以后，InnoDB就作为了默认的存储引擎。
2. MyISAM引擎的数据是通过二进制的方式存储在磁盘上，它在磁盘上体现为两个文件 一个是.MYD文件，D代表Data，是MyISAM的数据文件，存放数据记录， 一个是.MYI文件，I代表Index，是MyISAM的索引文件，存放索引实现机制如图所示。 因为索引和数据是分离的，所以在进行查找的时候，先从索引文件中找到数据的磁盘位置，再到数据  文件中找到索引对应的数据内容。
3. 在InnoDB存储引擎中，数据同样存储在磁盘上，它在磁盘上只有一个ibd文件，里面包含索引和数 据。 它的整体结构如图所示，在B+树的叶子节点里面存储了索引对应的数据，在通过索引进行检索的时  候，命中叶子节点，就可以直接从叶子节点中取出行数据。

第一个，数据存储的方式不同，MyISAM 中的数据和索引是分开存储的，而InnoDB是把索引和数据存储在同一个文件里面。 第二个，对于事务的支持不同，MyISAM不支持事务，而InnoDB支持ACID特性的事务处理 第三个，对于锁的支持不同，MyISAM只支持表锁，而InnoDB可以根据不同的情况，支持行锁，表 锁，间隙锁，临键锁 第四个，MyISAM不支持外键，InnoDB支持外键因此基于这些特性，我们在实际应用中，可以根据
不同的场景来选择合适的存储引擎。


  


## 分库分表
