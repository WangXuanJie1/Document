## 优化sql
1. 硬件和操作系统层面的优化：搭建mysql集群，设计读写分离。引入分库分表，针对热点数据做缓存
2. 架构设计的层面
3. mysql程序配置：修改最大连接数151
4. SQL优化：explain关键字执行计划，慢查询优化
  基于索引的数据扫描，避免索引上面的计算，where中like %尽量在右边，尽可能使用联合索引，查询有效列的集合少使用select*，小表驱动大表
  
## 分库分表
1. 水平分库：以字段为依据，按照一定策略（hash、range 等），将一个库中的数 据拆分到多个库中。
2. 水平分表：以字段为依据，按照一定策略（hash、range 等），将一个表中的数 据拆分到多个表中。
3. 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
4. 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和 扩展表）中。

## 分库分表中间件
harding-jdbc（当当）  Mycat  TDDL（淘宝）  Oceanus(58 同城数据库中间件)  vitess（谷歌开发的数据库中间件） Atlas(Qihoo 360)

## 分库分表存在的问题
1. 事务问题：需要用分布式事务啦  跨节点 
2. Join 的问题：解决这一问题可以分两次查询实现
3. 跨节点的 count,order by,group by 以及聚合函数问题：分别在各个节点上得到 结果后在应用程序端进行合并
4. 数据迁移，容量规划，扩容等问题
5. D问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单 可以考虑UUID

## 场景问题
1. **只分库不分表**：当数据库的读写访问量过高，还有可能会出现数据库连接不够用的情况。这个时候我们就需要 考虑分库，通过增加数据库实例的方式来获得更多的数据库连接，从而提升系统的并发性能。
2. **只分表不分库**： 当单表存储的数据量非常大的情况下，并且并发量也不高，数据库的连接也还够用。但是数据，写入和查询的性能出现了瓶颈，这个时候就需要考虑分表了。将数据拆分到多张表中来减少单表存储  的数据量，从而提升读写的效率
3. **又分库又分表**： 数据库访问量很大，或者是数据量大

## InnoDB 与MyISAM 的区别
1. 在Mysql 5.5之前，默认的存储引擎是MyISAM，从5.5以后，InnoDB就作为了默认的存储引擎。
2. MyISAM引擎的数据是通过二进制的方式存储在磁盘上，它在磁盘上体现为两个文件 一个是.MYD文件，D代表Data，是MyISAM的数据文件，存放数据记录， 一个是.MYI文件，I代表Index，是MyISAM的索引文件，存放索引实现机制如图所示。 因为索引和数据是分离的，所以在进行查找的时候，先从索引文件中找到数据的磁盘位置，再到数据  文件中找到索引对应的数据内容。
3. 在InnoDB存储引擎中，数据同样存储在磁盘上，它在磁盘上只有一个ibd文件，里面包含索引和数 据。 它的整体结构如图所示，在B+树的叶子节点里面存储了索引对应的数据，在通过索引进行检索的时  候，命中叶子节点，就可以直接从叶子节点中取出行数据。

第一个，数据存储的方式不同，MyISAM 中的数据和索引是分开存储的，而InnoDB是把索引和数据存储在同一个文件里面。 第二个，对于事务的支持不同，MyISAM不支持事务，而InnoDB支持ACID特性的事务处理 第三个，对于锁的支持不同，MyISAM只支持表锁，而InnoDB可以根据不同的情况，支持行锁，表 锁，间隙锁，临键锁 第四个，MyISAM不支持外键，InnoDB支持外键因此基于这些特性，我们在实际应用中，可以根据
不同的场景来选择合适的存储引擎。

## 数据库索引的原理，为什么要用 B+树，为什么不用二 叉树？
1. 因为B树是一种多路平衡树，用这种存储结构来存储大量数据，它的整个高度会相比二叉树来说，会 矮很多。 而对于数据库来说，所有的数据必然都是存储在磁盘上的，而磁盘IO的效率实际上是很低的，特别 是在随机磁盘IO的情况下效率更低。 所以树的高度能够决定磁盘IO的次数，磁盘IO次数越少，对于性能的提升就越大，这也是为什么采 用B树作为索引存储结构的原因。
但是
在Mysql的InnoDB存储引擎里面，它用了一种增强的B树结构，也就是B+树来作为索引和数据的存 储结构。 相比较于B树结构，B+树做了几个方面的优化。 B+树的所有数存储在叶子节点，非叶子节点只存储索引

B+树非叶子节点不存储数据，所以每一层能够存储的索引数量会增加，意味着B+树在层高相同的情 况下存储的数据量要比B树要多，使得磁盘IO次数更少。 在Mysql里面，范围查询是一个比较常用的操作，而B+树的所有存储在叶子节点的数据使用了双向 链表来关联，所以在查询的时候只需查两个节点进行遍历就行，而B树需要获取所有节点，所以B+树 在范围查询上效率更高。 在数据检索方面，由于所有的数据都存储在叶子节点，所以B+树的IO次数会更加稳定一些。 因为叶子节点存储所有数据，所以B+树的全局扫描能力更强一些，因为它只需要扫描叶子节点。但 是B树需要遍历整个树。 另外，基于B+树这样一种结构，如果采用自增的整型数据作为主键，还能更好的避免增加数据的时
候，带来叶子节点分裂导致的大量运算的问题。

1. 磁盘IO： B+数不存储数据，会存储更多索引
2. 范围查找
3. 全表扫描
4. 自增的时候避免大量运算

## 聚集索引和非聚集索引
1. 简单来说，聚集索引就是基于主键创建的索引，除了主键索引以外的其他索引，称为非聚集索二级索引
2. 一个聚集索引就是一个B+树，叶子节点就是一行数据同时也意味着每个表里面必须要有一个主键，如果没有主键，InnoDB 会默认选择或者添加一 个隐藏列作为主键索引来存储这个表的数据行。一般情况是建议使用自增 ID 作为主键，这样的话 ID 本身具有连续性，使得对应的数据也会按照顺序存储在磁盘上，写入性能和检索性能都很高。否则， 如果使用 UUID 这种随机 ID，那么在频繁插入数据的时候，就会导致随机磁盘 IO，从而导致性能较 低。需要注意的是，InnoDB 里面只能存在一个聚集索引，原因很简单，如果存在多个聚集索引，那 么意味着这个表里面的数据存在多个副本，造成磁盘空间的浪费，以及数据维护的困难。 由于在 InnoDB 里面，主键索引表示的是一种数据存储结构，所以如果是基于非聚集索引来查
询一条完整的记录，最终还是需要访问主键索引来检索。

## limit 1000000 加载很慢的话，你是怎么解决的呢？
1. 如果 id 是连续的，可以这样，返回上次查询的最大记录(偏移量)， 再往下 limit
2. 在业务允许的情况下限制页数：
3. order by + 索引（id 为索引）

## 事务的隔离级别
 回滚（脏读） 一个事务读取到另一个事务没有提交的数据，回滚之后出现脏读   
 修改（幻读） 事务在执行中读取到另一个事务提交的数据，出现问题          
 幻读：事务一执行的时候，多次读取一个数据，数据发生了变化   多次读取（不可重复度）
 
1. 读未提交（Read Uncommitted） 脏读+不可重复读+幻读
2. 读已提交（Read Committed）   不可重复读+幻读
3. 可重复读（Repeatable Read）  幻读
4. 串行化（Serializable） 
A Atomicity aetəˈmɪsəti 原子性 就是通过事务的提交回滚来实现的       undolog表（都成功都失败）
C Consistency kənˈsɪstənsi 一致性 保证数据进来一致的                数据完整性不被破坏
I Isolation aɪsəˈleɪʃn 每个更改数据的会话希望是相互不影响的          隔离级别
D Durability dʊrəˈbɪləti 持久性保证数据不会丢失                    事务提交成功就是永久性的

## 悲观锁和乐观锁
1. 悲观锁思想就是，当前线程要进来修改数据时，别的线程都得拒之门外~ 比如， 可以使用 select… for update ~（没有索引就是表锁）
2. 乐观锁思想就是，有线程过来，先放过去修改，如果看到别的线程没修改过， 就可以修改成功，如 果别的线程修改过，就修改失败或者重试。实现方式：乐观锁一般使用版本号机制或 CAS 算法实现


## in和exists
1. 因此，我们要选择最外层循环小的，也就是，如果 B 的数据量小于 A，适合使 用 in，如果 B的数据量大于 A，即适合选择 exists，这就是 in和exists 的
区别。执行顺序问题，前面数据大使用in，前面数据小使用exists

## MVCC 
MVCC,多版本并发控制,它是通过读取历史版本的数据，来降低并发事务冲突， 从而提高并发性能的一种机制。 MVCC需要关注这几个知识点：
事务版本号  表的隐藏列  undo log， read view

## 主从复制
1. 主库的更新事件(update、insert、delete)被写到 binlog
2. 从库发起连接，连接到主库
3. 此时主库创建一个 binlog dump thread，把binlog 的内容发送到从库
4. 从库启动之后，创建一个 I/O 线程，读取主库传过来的 binlog 内容并写入到 relaylog
5. 还会创建一个 SQL 线程，从 relay log 里面读取内容，从Exec_Master_Log_Pos 位置开始执行读取到的更新事件，将更新内容写入到slave 的db

## 索引下推
1. 索引下推优化是 MySQL 5.6 引入的，可以在索引遍历过程中，对索引中包含的字 段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
2. 最左前缀原则：MySQl 建立联合索引时，会遵循最左前缀匹配的原则， 即最左优先。如果你建立一个（a,b,c）的联合索引，相当于建立了(a)、(a,b)、(a,b,c)三个索引。
3. 覆盖索引：只需要在一棵索引树上就能获取 SQL 所需的所有列数据，无 需回表，速度更快。

## 表锁，页锁，行锁
1. 表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现 死锁。
2. 行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发 度高。
3. 页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般（数据划分）

内连接：在两张表进行连接查询时，只保留两张表中完全匹配的结果集
左连接：返回左表所有行+右表匹配的
右连接：返回右表所有行+左表匹配的

## 说一下数据库的三大范式
1. 数据表中的每一列（每个字段）都不可以再拆分。
2. 在第一范式的基础上，分主键列完全依赖于主键，而不能是依赖于主键 的一部分
3. 在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其 他非主键。

## 索引优点和缺点
1. 通过B+树的结构来存储数据，可以大大减少数据检索时的磁盘IO次数，从而提升数据查询的性能 B+树索引在进行范围查找的时候，只需要找到起始节点，然后基于叶子节点的链表结构往下读取即可，查询效率较高。
2. 数据的增加、修改、删除，需要涉及到索引的维护，当数据量较大的情况下，索引的维护会带来较大 的性能开销。

## 创建索引的方式
1. 在执行 CREATE TABLE时创✁索引 CREATE TABLE `employee` ( `id` int(11) NOT NULL, `name` varchar(255) DEFAULT NULL, `age` int(11) DEFAULT NULL, `date` datetime DEFAULT NULL, `sex` int(1) DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_name` (`name`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
2. 使用ALTER TABLE命令添加索引 ALTER TABLE table_name ADD INDEX index_name (column);
3. 使用 CREATE INDEX 命令创✁ CREATE INDEX index_name ON table_name (column);

## 索引覆盖
覆盖索引：查询列要被所✁的索引覆盖，不必从数据表中读取，换句话说查询列 要被所使用的索引覆盖。

## 回表
回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表

## 七锁
1. InnoDB 呢实现了两种标准的行级锁：共享锁（简称 S 锁）、排他锁（简称 X 锁）。共享锁：简称为 S锁，在事务要读取一条记录时，需要先获取该记录的 S锁。  排他锁：简称 X 锁，在事务需要改动一条记录时，需要先获取该记录的 X锁。
2.  意向锁： 什么是意向锁呢？意向锁是一种不与行级锁冲突的表级锁。未来的某个时刻， 事务可能要加共享或者排它锁时，先提前声明一个意向。注意一下，意向锁，
是一个表级别的锁哈。
3.  记录锁：记录锁是最简单的行锁，仅仅锁住一行。如：SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE，如果 C1 字段是主键或者是唯一索引的话，这个 SQL 会加一个记录锁（Record Lock）
4.  间隙锁：为了解决幻读问题，InnoDB 引入了间隙锁(Gap Lock)。间隙锁是一种加在两 个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。它
锁住的是一个区间，而不仅仅是这个区间中的每一条数据。
5.  临键锁： Next-key 锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录 前面间隙上的锁。说得更具体一点就是:临键锁会封锁索引记录本身，以及索引
记录之前的区间，即它的锁区间是前开后闭，比如(5,10]
6.  插入意向锁： 插入意向锁,是插入一行记录操作之前设置的一种间隙锁，这个锁释放了一种插 入方式的信号。 它解决的问题：多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。
7.  自增锁： 自增锁是一种特殊的表级别锁。它是专门针对 AUTO_INCREMENT类型的列，对 于这种列，如果表中新增数据时就会去持有自增锁。简言之，如果一个事务正 在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。

## 死锁
竞争资源，互相等待，永久等待
1. 互斥条件
2. 占有不释放
3. 不可抢占
4. 循环等待

## count(1)、count(*) 与 count(列名) 的区别？
1. count(*)包括了所有✁列，相当于行数，在统计结果✁时候，不会忽略列值为 NULL（整个数据）
2. count(1)包括了忽略所有列，用 1 代表代码行，在统计结果✁时候，不会忽略列 值为NULL（扫描到一个数据，返回1）
3. count(列名)只包括列名那一列，在统计结果✁时候，会忽略列值为空（这里✁空 不是只空字符串或者 0，而是表示 null）✁计数，即某个字段值为 NULL 时，不
统计。（有索引走索引，为null不统计）

## SQL 约束有哪几种呢？ 
1. NOT NULL: 约束字段✁内容一定不能为 NULL。  UNIQUE: 约束字段唯一性，一个表允许有多个 Unique 约束。 
2. PRIMARY KEY: 约束字段唯一，不可重复，一个
3. FOREIGN KEY: 用于预防破坏表之间连接✁动作，也能防止非法数据插入外键
4. CHECK: 用于控制字段✁值范围

## UNION 与UNION ALL 的区别
1. Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序(去重，默认排序)
2. Union All：对两个结果集进行并集操作，包括重复行，不进行排序（不去重）







