## es分布式
1. 分布式机制，分布式数据存储和共享
2. 分片机制
3. 集群发现机制，
4. shard负载均衡，平均分配
5. shard副本，新增副本数

## es垂直扩容和水平扩容
1. 垂直扩容，使用更加强大的服务器代理老服务器
2. 水平扩容，采用更多的机器

##增加和删除节点

## master节点
1. 创建删除节点
2. 创建删除索引

## 节点对等的分布式架构
1. 每个index包含一个或者多个分片，主分片和副本分片
2. 增减节点的时候，分片会自动负载均衡的： 分片自动负载均衡，向空闲机器转移，扩容极限是节点大于整体分片数，则必须有空闲的机器。超出扩容极限，可以添加副本数，如果设置副本数为2
   。只要有一个索引的所有主分片在，集群就可以运行。
4. 主分片创建索引就指定了，副本是可以更改的
5. 主分片默认是1，副本分片默认是1
6. 主分片和副本分片不能放在一个节点上面

## 容错机制
1. 一个节点宕机，重新选举master选举。新的master将丢失的主分片提升为主分片。集群状态是黄色，少副本分片
2. 重启故障nod，将缺失的副本数据copy一份到新机器上面

# 文档存储机制
## 数据路由
1. 文档如何存储到节点上，一个文档只会存储到一个主分片上面。路由算法是hash算法，路由id取模机器总数取出的数值就是机器
2. 手动指定routingkey，某一个属性相同的数据就落到了一个分片中了，缺点：数据设计不好就会数据倾斜      put /test_index/_doc/15?routing=tom
3. 涉及到以往数据的查询的时候，主分片的数据是不可变的。有routingkey的存在不能发生变化

## 图解文档的增删改
1. 客户端发送一个node发送请求，这个节点就是协调节点
2. 协调节点对文档进行路由计算，转发给相应的node
3. 实际上面的node主分片请求，将数据同步到副本节点中
4. 返回客户端信息

## 文档的查询机制
1. 客户端发送任意的请求到node，协调节点
2. 协调节点进行路由计算，将id取模主分片数，可以查询到是那一台机器。将请求转发到机器上。
3. 使用轮询算法，在主节点和副本数据中选一个副本数据只读。将结果返回客户端

## bulk api的奇特json格式
1. 每个操作都转发到node的分片执行
2. 使用json格式，将json解析成jsonarray对象，判断每一个请求进行路由解析，分发。
3. 判断请求数据，将同一个路由的机器上的请求汇总起来
4. 网络传输中序列化，将数据发送到节点中
5. 占用很多内存请求。导致es的java虚拟机就会出现问题
``` java
Elasticsearch 中的 Bulk API 允许客户端执行多个索引、更新、删除或其他操作，通过单个网络请求来同时将这些操作发送到 Elasticsearch。Bulk API 可以提高索引数据的效率和性能，特别是在向 Elasticsearch 中写入大量数据时比较适用。

以下是 Bulk API 的基本用法：

准备数据
Bulk API 接受 JSON 格式的数据作为输入。每个操作都表示为一条 JSON 文档，并以换行符 \n 分隔。例如，以下是三个不同的操作，每个操作都表示为一条 JSON 文档：

{ "index" : { "_index" : "myindex", "_id" : "1" } }
{ "field1" : "value1" }

{ "index" : { "_index" : "myindex", "_id" : "2" } }
{ "field1" : "value2" }

{ "delete" : { "_index" : "myindex", "_id" : "3" } }
文档中的第一行指定了操作类型，可以是 index、update、delete 等等。在每个操作的下一行指定要执行操作的数据。在 index 和 update 操作中需要提供文档ID，而在 delete 操作中只需要提供索引名称和文档ID。

发送请求
使用 HTTP POST 方法向 Elasticsearch 发送 Bulk API 请求。以下是一个示例请求：

POST /myindex/_bulk
{ "index" : { "_id" : "1" } }
{ "field1" : "value1" }

{ "index" : { "_id" : "2" } }
{ "field1" : "value2" }

{ "delete" : { "_id" : "3" } }
在请求的 URI 中指定要执行操作的索引名称（这里是 myindex），并将数据作为请求的主体发送。

处理响应
Elasticsearch 返回一个 JSON 格式的响应，其中包含每个操作的结果和状态。以下是一个示例响应：

{
  "took": 15,
  "errors": false,
  "items": [
    {
      "index": {
        "_index": "myindex",
        "_type": "_doc",
        "_id": "1",
        "_version": 1,
        "result": "created",
        "_shards": {
          "total": 2,
          "successful": 1,
          "failed": 0
        },
        "_seq_no": 0,
        "_primary_term": 1
      }
    },
    {
      "index": {
        "_index": "myindex",
        "_type": "_doc",
        "_id": "2",
        "_version": 1,
        "result": "created",
        "_shards": {
          "total": 2,
          "successful": 1,
          "failed": 0
        },
        "_seq_no": 1,
        "_primary_term": 1
      }
    },
    {
      "delete": {
        "_index": "myindex",
        "_type": "_doc",
        "_id": "3",
        "_version": 2,
        "result": "deleted",
        "_shards": {
          "total": 2,
          "successful": 1,
          "failed": 0
        },
        "_seq_no": 2,
        "_primary_term": 1
      }
    }
  ]
}
在响应中，每个操作都表示为一个 JSON 对象，其中包含了操作的类型、目标文档的 ID、执行结果及相关信息。

以上是 Bulk API 的基本用法，可以通过 Bulk API 将大量数据一次性写入 Elasticsearch，提高索引数据的效率和性能。
```
