## equals 与==✁区别
1. 如果✁基本类型，==表示判断它们值✁否相等；如果✁引用对象，==表示判断两个对象指向✁内存地址✁否相同。
2. 如果✁字符串，表示判断字符串内容✁否相同；如果✁ object 对象✁方法，比较✁也✁引用✁内存地址值；,如果✁ object 对象✁方法，比较✁也✁引用✁内存地址值；

final, finally, finalize ✁区别
1. final修饰属性，方法，类，表示不能重新赋值，方法不可覆盖，类不能继承
2. finally，异常处理语句结构，一般以try-catch-finally出现，表示代码块总执行
3. finalize：Object方法一般由垃圾回收器调用，调用systemctl.gc()的时候，垃圾回收器调用finalize()方法回收垃圾

## 重载和重写的区别
1. 重写必须继承，重载不用
2. 重载表示同一个类中可以有多个名称相同✁方法，但这些方法✁参数列表各不相同
3. 重写表示子类中✁方法与父类中✁某个方法✁名称和参数完全相同啦，通过子类实 例对象调用这个方法时，将调用子类中✁定义方法，这相当于✃父类中定义✁那个完全相同✁方法给覆盖了，这✁面向对象编程✁多态性✁一种表现。
4. 重写✁方法修饰符大于等于父类✁方法，即访问权限只能比父类✁更大，不能更小， 而重载和修饰符无关

## 两个对象✁ hashCode()相同，则 equals()✁否也一定为 true？
1. 两个对象 equals 相等，则它们✁ hashcode 必须相等，如果两个对象 ✁hashCode()相同，则 equals()不一定为 true
2. 两个对象✁ equals()不相等，那么对这两个对象中✁任一对象上调用 hashCode 方法不要求一定生成不同✁整数结果。但✁，为不相等✁对象生成不同整数结果可以提高哈希表✁性能。

## BIO、NIO、AIO 有什么区别
1. BIO：线程发起 IO 请求，不管内核✁否准备好 IO 操作，从发起请求起，线程 一直阻塞，直到操作完成
2. NIO：线程发起 IO 请求，立即返回；内核在做好 IO 操作✁准备之后，通过调 用注册✁回调函数通知线程做 IO 操作，线程开始阻塞，直到操作完成。
3. AIO：线程发起 IO 请求，立即返回；内存做好 IO 操作✁准备之后，做 IO 操 作，直到操作完成或者失败，通过调用注册✁回调函数通知线程做 IO 操作完成或者失败

## Comparator 与 Comparable 有什么区别？

## 说说 Java 中多态的实现原理
1. 多态机制包括静态多态（编译时多态）和动态多态（运行时多态）
2. 静态多态比如说重载，动态多态一般指在运行时才能确定调用哪个方法
3. 我们通常所说✁多态一般指运行时多态，也就✁编译时不确定究竟调用哪个具体方 法，一直等到运行时才能确定

## int 和 Integer 有什么区别，还有 Integer 缓存✁实现
1. int 默认值是0 integer默认值是null。integer需要进行判空
2. integer缓存机制，为了节省内存和提高性能。integer在内部使用相同默认值是-128--127之间可以通过AutoBoxCacheMax进行修改
3. Integer存储在堆内存，int类型是直接存储在栈空间

## 说说反射✁用途及实现原理，Java 获取反射✁三种方法
1. Class.forName 静态方法
2. 使用类✁.class 方法
3. 使用实例对象✁ getClass( ) 方法

## notify ✁唤醒一个处于该对象 wait ✁线程，而 notifyAll ✁唤醒所有处于该对 象wait✁线程，但✁唤醒不等于就能执行了，需要得到锁对象才能有权利继续执行，而锁只有一✃， 所以多个线程被唤醒时需要争取该锁

## 反射中，Class.forName 和 ClassLoader ✁区别
1. ClassLoader 负责加载 Java 类✁字节代码到 Java 虚拟机中，Class.forName 其实✁调用了 ClassLoader

## JDK 动态代理与 cglib 实现的区别
1. java 动态代理✁利用反射机制生成一个实现代理➓口✁匿名类，在调用具体方法 前调用 InvokeHandler 来处理
2. cglib 动态代理✁利用 asm 开源包，对代理对象类✁ class 文件加载进来，通过 修改其字节码生成子类来处理

## synchronized ✁实现原理以及锁优化
1. synchronized 作用于「方法」或者「代码块」，保证被修饰✁代码在同一时间只 能被一个线程访问。
2. synchronized 修饰代码块时，JVM 采用「monitorenter、monitorexit」两个 指令来实现同步
3. synchronized 修饰同步方法时，JVM 采用「ACC_SYNCHRONIZED」标记符来 实现同步
4. monitorenter、monitorexit 或者ACC_SYNCHRONIZED 都✁「基于Monitor 实现」
5. 实例对象里有对象头，对象头里面有 Mark Word，Mark Word 指针指向了 「monitor」
6. Monitor 其实✁一种「同步工具」，也可以说✁一种「同步机制」
7. Monitor 其实✁一种「同步工具」，也可以说✁一种「同步机制」

## ThreadLocal ✁实现原理
1. Thread 类有一个类型为 ThreadLocal.ThreadLocalMap ✁实例变量 threadLocals，即每个线程都有一个属于自己✁ ThreadLocalMap。
2. ThreadLocalMap 内部维护着 Entry 数组，每个Entry 代表一个完整✁对象， key✁ThreadLocal 本身，value ✁ThreadLocal ✁泛型值
3. 每个线程在往 ThreadLocal 里设置值✁时候，都✁往自己✁ ThreadLocalMap 里存，读也✁以某个 ThreadLocal 作为引用，在自己✁map里找对应✁ key，从而实现了线程隔离

## 说说 CountDownLatch 与 CyclicBarrier 区别 要点
1. CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才 能执行。递减计数。（单个线程等待多i个线程，多个线程等待的场景）
2. CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。加法计数
3. CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法 重置
4. CyclicBarrier能处理更为复杂的业务场景，比如计算发生错误，可以结束阻塞，重置计数器， 重新执行程序
5. CyclicBarrier提供getNumberWaiting()方法，可以获得CyclicBarrier阻塞的线程数量，还 提供isBroken()方法，可以判断阻塞的线程是否被中断，等等
6. CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程

## 多态：
1. 它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不 同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。
2. 重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定，运行的时候调用的是 确定的方法。
3. 继承
4. 重写
5. 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方 法，又能调用子类的方法。

## 抽象类和接口的区别：
1. 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
3. 接口中不能含有静态代码块及静态方法，而抽象类可以有静态代码块和静态方法；
4. 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽 象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。一个类只能继承一个抽象类，而一个类却可以实现多个接口。
5. 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是 一种辐射式设计。

## 包装类型是什么？ 基本类型和包装类型有什么区别？
1. 包装类型可以为 null， 而基本类型不可以
2. 包装类型可用于泛型，基本类型不行

## 自动装箱和自动拆箱
9是属于基本数据类型的，原则上它是不能直接赋值给一个对象Integer的。但jdk1.5 开始引入了自动装 箱/拆箱机制，就可以进行这样的声明，自动将基本数据类型转化为对应的封装类型，成为一个对象以后
就可以调用对象所声明的所有的方法。
自动拆箱：对象转换为基本数据类型

## log和system.out.print的区别
1. 目的，log记录程序事件，状态和调试信息，system用于控制台输出
2. log更加灵活，可配置（日志级别和输出的文件位置）
3. 标准输出流和log基于日志框架实现的

## Spring 通过 XML 配置模式装载 Bean 的过程：
1. 将程序内所有 XML 或 Properties 配置文件加载入内存中
2. Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信 息；
3. 使用反射机制，根据这个字符串获得某个类的Class实例
4. 动态配置实例的属性


