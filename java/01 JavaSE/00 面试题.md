## equals 与==✁区别
1. 如果✁基本类型，==表示判断它们值✁否相等；如果✁引用对象，==表示判断两个对象指向✁内存地址✁否相同。
2. 如果✁字符串，表示判断字符串内容✁否相同；如果✁ object 对象✁方法，比较✁也✁引用✁内存地址值；,如果✁ object 对象✁方法，比较✁也✁引用✁内存地址值；

final, finally, finalize ✁区别
1. final修饰属性，方法，类，表示不能重新赋值，方法不可覆盖，类不能继承
2. finally，异常处理语句结构，一般以try-catch-finally出现，表示代码块总执行
3. finalize：Object方法一般由垃圾回收器调用，调用systemctl.gc()的时候，垃圾回收器调用finalize()方法回收垃圾

## 重载和重写的区别
1. 重写必须继承，重载不用
2. 重载表示同一个类中可以有多个名称相同✁方法，但这些方法✁参数列表各不相同
3. 重写表示子类中✁方法与父类中✁某个方法✁名称和参数完全相同啦，通过子类实 例对象调用这个方法时，将调用子类中✁定义方法，这相当于✃父类中定义✁那个完全相同✁方法给覆盖了，这✁面向对象编程✁多态性✁一种表现。
4. 重写✁方法修饰符大于等于父类✁方法，即访问权限只能比父类✁更大，不能更小， 而重载和修饰符无关
5. 重写✁方法修饰符大于等于父类✁方法，即访问权限只能比父类✁更大，不能更小， 而重载和修饰符无关

## 两个对象✁ hashCode()相同，则 equals()✁否也一定为 true？
1. 两个对象 equals 相等，则它们✁ hashcode 必须相等，如果两个对象 ✁hashCode()相同，则 equals()不一定为 true
2. 两个对象✁ equals()不相等，那么对这两个对象中✁任一对象上调用 hashCode 方法不要求一定生成不同✁整数结果。但✁，为不相等✁对象生成不同整数结果可以提高哈希表✁性能。

## BIO、NIO、AIO 有什么区别
1. BIO：线程发起 IO 请求，不管内核✁否准备好 IO 操作，从发起请求起，线程 一直阻塞，直到操作完成
2. NIO：线程发起 IO 请求，立即返回；内核在做好 IO 操作✁准备之后，通过调 用注册✁回调函数通知线程做 IO 操作，线程开始阻塞，直到操作完成。
3. AIO：线程发起 IO 请求，立即返回；内存做好 IO 操作✁准备之后，做 IO 操 作，直到操作完成或者失败，通过调用注册✁回调函数通知线程做 IO 操作完成或者失败

## Comparator 与 Comparable 有什么区别？

## 说说 Java 中多态的实现原理
1. 多态机制包括静态多态（编译时多态）和动态多态（运行时多态）
2. 静态多态比如说重载，动态多态一般指在运行时才能确定调用哪个方法
3. 我们通常所说✁多态一般指运行时多态，也就✁编译时不确定究竟调用哪个具体方 法，一直等到运行时才能确定

## int 和 Integer 有什么区别，还有 Integer 缓存✁实现
1. int 默认值是0 integer默认值是null。integer需要进行判空
2. integer缓存机制，为了节省内存和提高性能。integer在内部使用相同默认值是-128--127之间可以通过AutoBoxCacheMax进行修改
3. Integer存储在堆内存，int类型是直接存储在栈空间

## 说说反射✁用途及实现原理，Java 获取反射✁三种方法
1. Class.forName 静态方法
2. 使用类✁.class 方法
3. 使用实例对象✁ getClass( ) 方法

## 守护线程✁什么？用什么方法实现守护线程

## notify ✁唤醒一个处于该对象 wait ✁线程，而 notifyAll ✁唤醒所有处于该对 象wait✁线程，但✁唤醒不等于就能执行了，需要得到锁对象才能有权利继续执行，而锁只有一✃， 所以多个线程被唤醒时需要争取该锁

## 反射中，Class.forName 和 ClassLoader ✁区别
1. ClassLoader 负责加载 Java 类✁字节代码到 Java 虚拟机中，Class.forName 其实✁调用了 ClassLoader

## JDK 动态代理与 cglib 实现的区别
1. java 动态代理✁利用反射机制生成一个实现代理➓口✁匿名类，在调用具体方法 前调用 InvokeHandler 来处理
2. cglib 动态代理✁利用 asm 开源包，对代理对象类✁ class 文件加载进来，通过 修改其字节码生成子类来处理

## synchronized ✁实现原理以及锁优化
1. synchronized 作用于「方法」或者「代码块」，保证被修饰✁代码在同一时间只 能被一个线程访问。
2. synchronized 修饰代码块时，JVM 采用「monitorenter、monitorexit」两个 指令来实现同步
3. synchronized 修饰同步方法时，JVM 采用「ACC_SYNCHRONIZED」标记符来 实现同步
4. monitorenter、monitorexit 或者ACC_SYNCHRONIZED 都✁「基于Monitor 实现」
5. 实例对象里有对象头，对象头里面有 Mark Word，Mark Word 指针指向了 「monitor」
6. Monitor 其实✁一种「同步工具」，也可以说✁一种「同步机制」
7. Monitor 其实✁一种「同步工具」，也可以说✁一种「同步机制」

## ThreadLocal ✁实现原理
1. Thread 类有一个类型为 ThreadLocal.ThreadLocalMap ✁实例变量 threadLocals，即每个线程都有一个属于自己✁ ThreadLocalMap。
2. ThreadLocalMap 内部维护着 Entry 数组，每个Entry 代表一个完整✁对象， key✁ThreadLocal 本身，value ✁ThreadLocal ✁泛型值
3. 每个线程在往 ThreadLocal 里设置值✁时候，都✁往自己✁ ThreadLocalMap 里存，读也✁以某个 ThreadLocal 作为引用，在自己✁map里找对应✁ key，从而实现了线程隔离

## 说说 CountDownLatch 与 CyclicBarrier 区别 要点
1. CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才 能执行。递减计数。（单个线程等待多i个线程，多个线程等待的场景）
2. CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。加法计数
3. CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法 重置
4. CyclicBarrier能处理更为复杂的业务场景，比如计算发生错误，可以结束阻塞，重置计数器， 重新执行程序
5. CyclicBarrier提供getNumberWaiting()方法，可以获得CyclicBarrier阻塞的线程数量，还 提供isBroken()方法，可以判断阻塞的线程是否被中断，等等
6. CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程



