## equals 与==✁区别
1. 如果✁基本类型，==表示判断它们值✁否相等；如果✁引用对象，==表示判断两个对象指向✁内存地址✁否相同。
2. 如果✁字符串，表示判断字符串内容✁否相同；如果✁ object 对象✁方法，比较✁也✁引用✁内存地址值；,如果✁ object 对象✁方法，比较✁也✁引用✁内存地址值；

final, finally, finalize ✁区别
1. final修饰属性，方法，类，表示不能重新赋值，方法不可覆盖，类不能继承
2. finally，异常处理语句结构，一般以try-catch-finally出现，表示代码块总执行
3. finalize：Object方法一般由垃圾回收器调用，调用systemctl.gc()的时候，垃圾回收器调用finalize()方法回收垃圾

## 重载和重写的区别
1. 重写必须继承，重载不用
2. 重载表示同一个类中可以有多个名称相同✁方法，但这些方法✁参数列表各不相同
3. 重写表示子类中✁方法与父类中✁某个方法✁名称和参数完全相同啦，通过子类实 例对象调用这个方法时，将调用子类中✁定义方法，这相当于✃父类中定义✁那个完全相同✁方法给覆盖了，这✁面向对象编程✁多态性✁一种表现。
4. 重写✁方法修饰符大于等于父类✁方法，即访问权限只能比父类✁更大，不能更小， 而重载和修饰符无关
5. 重写✁方法修饰符大于等于父类✁方法，即访问权限只能比父类✁更大，不能更小， 而重载和修饰符无关

## 两个对象✁ hashCode()相同，则 equals()✁否也一定为 true？
1. 两个对象 equals 相等，则它们✁ hashcode 必须相等，如果两个对象 ✁hashCode()相同，则 equals()不一定为 true
2. 两个对象✁ equals()不相等，那么对这两个对象中✁任一对象上调用 hashCode 方法不要求一定生成不同✁整数结果。但✁，为不相等✁对象生成不同整数结果可以提高哈希表✁性能。

## BIO、NIO、AIO 有什么区别
1. BIO：线程发起 IO 请求，不管内核✁否准备好 IO 操作，从发起请求起，线程 一直阻塞，直到操作完成
2. NIO：线程发起 IO 请求，立即返回；内核在做好 IO 操作✁准备之后，通过调 用注册✁回调函数通知线程做 IO 操作，线程开始阻塞，直到操作完成。
3. AIO：线程发起 IO 请求，立即返回；内存做好 IO 操作✁准备之后，做 IO 操 作，直到操作完成或者失败，通过调用注册✁回调函数通知线程做 IO 操作完成或者失败

## Comparator 与 Comparable 有什么区别？

## 说说 Java 中多态的实现原理
1. 多态机制包括静态多态（编译时多态）和动态多态（运行时多态）
2. 静态多态比如说重载，动态多态一般指在运行时才能确定调用哪个方法
3. 我们通常所说✁多态一般指运行时多态，也就✁编译时不确定究竟调用哪个具体方 法，一直等到运行时才能确定

## int 和 Integer 有什么区别，还有 Integer 缓存✁实现
1. int 默认值是0 integer默认值是null。integer需要进行判空
2. integer缓存机制，为了节省内存和提高性能。integer在内部使用相同默认值是-128--127之间可以通过AutoBoxCacheMax进行修改
3. Integer存储在堆内存，int类型是直接存储在栈空间

## 说说反射✁用途及实现原理，Java 获取反射✁三种方法
1. Class.forName 静态方法
2. 使用类✁.class 方法
3. 使用实例对象✁ getClass( ) 方法

## 守护线程✁什么？用什么方法实现守护线程

## notify ✁唤醒一个处于该对象 wait ✁线程，而 notifyAll ✁唤醒所有处于该对 象wait✁线程，但✁唤醒不等于就能执行了，需要得到锁对象才能有权利继续执行，而锁只有一✃， 所以多个线程被唤醒时需要争取该锁

## 反射中，Class.forName 和 ClassLoader ✁区别
1. ClassLoader 负责加载 Java 类✁字节代码到 Java 虚拟机中，Class.forName 其实✁调用了 ClassLoader

## JDK 动态代理与 cglib 实现的区别
1. java 动态代理✁利用反射机制生成一个实现代理➓口✁匿名类，在调用具体方法 前调用 InvokeHandler 来处理
2. cglib 动态代理✁利用 asm 开源包，对代理对象类✁ class 文件加载进来，通过 修改其字节码生成子类来处理
3. 
