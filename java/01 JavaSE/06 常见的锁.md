# 数据库层面的锁
## 乐观锁
## 悲观锁
## 表锁
## 页锁
## 行锁



# java层面的锁
## 互斥锁
## 可重入锁
1. 可重入锁的实现机制主要基于计数器，每次加锁时都会增加计数器的值，解锁时则会相应地减少计数器的值，只有当计数器的值为0时才表示锁已被完全释放。
2. 在多线程环境中，如果当前线程已经获得某个对象的锁，再次请求该锁时只需增加计数器的值即可，而不必重新竞争和获取锁，从而提高了程序的执行效率和性能。
3. 需要注意的是，可重入锁虽然避免了死锁和资源竞争等问题，但也可能存在潜在的安全隐患，
4. 因为同一个线程可以多次获取锁，而另一个线程无法获取到相应的锁，从而导致数据同步的问题。为了避免这种情况的发生，
5. 应该合理使用可重入锁，并尽可能缩小锁的范围，避免出现过度并发的情况，从而提高程序的可靠性和稳定性。

## 偏向锁
1. 偏向锁主要用于解决执行单线程场景下的性能问题。当一个对象被创建时，对象头中的 mark word 默认值是 01，表示对象处于未锁定状态。
2. 当该对象第一次被某个线程锁定时，JVM 会将 mark word 的值修改为线程 ID，并设置标志位为 01，
3. 表示当前对象进入了偏向模式。当其他线程访问该对象时，发现该对象已经被加上偏向锁，则无需再次进入同步块，直接使用线程 ID 和栈中的锁记录进行配对。
4. 如果竞争过多或者存在继续使用这个对象的其他线程，那么偏向锁就不再有效，加锁的代价也就超过了获得锁的代价。
5. 需要注意的是，在 JDK 6 及更早版本中，偏向锁默认是开启的，而在 JDK 7 及以后的版本中，偏向锁默认是关闭的，需要通过参数开启。

## 轻量级锁
1. 轻量级锁是在多线程竞争情况下替代重量级锁的一种优化手段。当一个线程访问一个对象时，将会在对象头上记录当前线程的 ID，并将对象头的 mark word 与线程栈中的锁记录进行比对。（cas）
2. 如果两者匹配成功，则表示该线程获得了轻量级锁，可以直接执行同步代码块。如果比对失败，则说明已经有其他线程持有该对象的锁了，
3. 则需要膨胀为重量级锁。需要注意的是，轻量级锁只适用于短时间内能够解决竞争的情况，否则会浪费更多的 CPU 时间。

## 重量级锁
1. 重量级锁是传统意义上的锁机制，在多线程竞争激烈、锁的竞争时间较长等情况下使用。
2. 重量级锁的加锁和解锁操作需要通过操作系统提供的系统调用来完成，因此开销较大且效率低下。
3. 重量级锁在进入同步块之前首先要获取到锁对象的 monitor，进入阻塞状态等待 monitor 的唤醒信号。由于需要频繁地进行内核态和用户态之间的切换，因此重量级锁的效率比较低，不适合在高并发和竞争激烈的场景下使用。

## 自旋锁
1. 自旋锁：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待 锁的释放，不让出CPU。
2. 如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。
3. 但是它也存在缺点：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。

## 自适应自旋锁
自适应自旋锁：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋 的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。
