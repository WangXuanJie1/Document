导致rabbitmq服务器重启，期间会导致消息丢失，需要手动确认恢复。

确认机制方案：发送消息备份（缓存），当交换机收到消息就清除缓存。交换机和队列之间。交换机存在队列不存在的时候，消息就会丢失。
在配置文件中添加：   ```publisher-confirm-type: correlated  实现confirmCallback接口```

消息回退机制：在消息不可达的时候，```配置文件添加 publish-returns=true  实现ReturnCallback接口。消息不能达到目的地的时候就进行消息回退```

1. 备份交换机：交换机出现问题无法接受到消息，要求交换机发布确认，如果队列收不到也是，还有一种就是备份交换机。将消息发送给备份交换机。（消息检测和报警）
两个队列，备份队列和报警队列

2. 幂等性：同一操作或者多次请求的结果是一致的。重复提交的问题；消息被被重复消费。消息幂等性是用全局id，每次消费的时候进行判断
唯一id+指纹码机制：一些规则加时间戳，不是系统生成的，基本是业务规则拼接过来的，但是一定保证唯一性，使用查询语句判断
Redis原子性：setnx命令

3. 优先级队列：订单催付的场景，大客户和小客户进行推送。订单优先处理。曾今是redis存放定时轮询，redis只能做list简单的消息队列，并不能实现优先队列。使用rabbitmq实现优先级
对消息进行排序，队列中设置参数，```params.put("x-max-priority",10)   在发送消息的时候确定消息的优先级    官方允许0-255之间
AMQP.BasicProperties.build().priority(5),build()```

4. 惰性队列：消费者下线或者消息存放地，消息存储在内存中还是磁盘中。正常是在内存中的，惰性队列是在磁盘中的。队列有两种模式，default和lazy。可以在 注册队列的时候参数中设置。
```params.put("x-queue-mode",lazy)```
将消息存放到磁盘中。内存消耗小，惰性队列消费慢




