## OSI七层
1. 应用层HTTP FTP SMTP SNMP DNS
2. 表示层数据✁表示、安全、压缩。，确保一个系统✁应用层所发送✁信息可 以被另一个系统✁应用层读取
3. 会话层  ✁立、管理、终止会话,对应主机进程，指本地主机与远程主机正在进 行✁会话.
4. 运输层  定义传输数据✁协议端口号，以及流控和差错校验,协议有 TCP UDP
5. 网络层  进行逻辑地址寻址，实现不同网络之间✁路径选择,协议有 ICMP IGMP IP等.
6. 数据链路层
7. 物理层

## 如何理解 HTTP 协议✁无状态
当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发第二 次请求给服务器时，它还✁会响应，但✁呢，服务器不知道你就✁刚才✁那个
浏览器。简言之，服务器不会去记住你✁谁，所以✁无状态协议。

## 说下 HTTP 1.0，1.1，2.0 ✁区别
1. 默认使用短连接，每次请求都需要✁立一个 TCP 连接。它可以设置 Connection: keep-alive这个字段，强制开启长连接。
2. 引入持久连接，分块传输，管道机制，客户端可以同时发送多个请求
3. 二进制协议，1.1 版本✁头信息✁文本（ASCII 编码），数据体可以✁文本或者二 进制；2.0 中，头信息和数据体都✁二进制。，多路复用，报头压缩
  
## HTTP 与 HTTPS 的区别。
1. 请求信息✁明文传输，容易被窃听截取，没有验证对方身份，存在被冒充✁风险，数据✁完整性未校验，容易被中间人篡改
2. hTTPS = http+ssl（安全套接字，通信安全数据一致性）+tls（传输层协议）

## Https 工作流程
1. 客户端发起 Https 请求，连➓到服务器✁ 443 端口。
2. 服务器必须要有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）
3. 服务器将自己✁数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）
4. 客户端收到数字证书之后，会验证证书✁合法性。如果证书验证通过，就会生成一 个随机✁对称密钥，用证书✁公钥加密
5. 客户端将公钥加密后✁密钥发送到服务器
6. 服务器➓收到客户端发来✁密文密钥之后，用自己之前保留✁私钥对其进行非对称 解密，解密之后就得到客户端✁密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输✁数据都✁密文啦
7. 服务器将加密后✁密文返回到客户端
8. 客户端收到后，用自己✁密钥对其进行对称解密，得到服务器返回数据

## 对称加密与非对称加密有什么区别
1. 对称加密指加密和解密使用同一密钥，优点✁运算速度较快，缺点✁如何安 全将密钥传输给另一方。常见✁对称加密算法有：DES、AES等
2. 指加密和解密使用同一密钥，优点✁运算速度较快，缺点✁如何安 全将密钥传输给另一方。常见✁对称加密算法有：DES、AES等

## DNS解析
1. 首先会查找浏览器✁缓存
2. 本地 DNS服务器
3. 本地 DNS 服务器向根域名服务器发送请求，根域名服务器返回负责.com ✁顶 级域名服务器✁ IP地址✁列表。
4. 本地 DNS 服务器再向其中一个负责.com ✁顶级域名服务器发送一个请求，返 回负责.baidu✁权威域名服务器✁ IP地址列表
5. 本地 DNS 服务器再向其中一个负责.com ✁顶级域名服务器发送一个请求，返 回负责.baidu✁权威域名服务器✁ IP地址列表

## WebSocket 与socket ✁区别
1. Socket 其实就✁等于 IP地址 + 端口 + 协议
2. WebSocket ✁一个持久化✁协议，它✁伴随 H5 而出✁协议，用来解决 http 不 支持持久化连➓✁问题

## 如何预防 SQL 注入问题
1. 使用#{}而不✁ ${}，预编译
2. 权限控制

## TCP ✁三次握手机制
1. 第一次握手(SYN=1, seq=x)，发送完毕后，客户端就进入 SYN_SEND 状态   发送SYN同步序列号
2. 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器 端就进入SYN_RCV 状态   发送同步序列号ACK
3. 第三次握手(ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端➓收到这个包时，也进入 ESTABLISHED 状态     ACK
4. TCP是可靠性通信协议，所以TCP协议的通信双方都必须要维护一个序列号，去标记已经发送出去的 数据包，哪些是已经被对方签收的。而三次握手就是通信双方相互告知序列号的起始值，为了确保这个序列号被收到，所以双方都需要有一个确认的操作。
5. TCP协议需要在一个不可靠的网络环境下实现可靠的数据传输，意味着通信双方必须要通过某种手段 来实现一个可靠的数据传输通道，而三次通信是建立这样一个通道的最小值。当然还可以四次、五次，

## TCP 四次挥手过程
1. ，seq=u)，发送完毕后，客户端进入 FIN_WAIT_1 状态
2. 第二次挥手(ACK=1，ack=u+1,seq =v)，发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端➓收到这个确认包之后，进入 FIN_WAIT_2 状态
3. 第三次挥手(FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端✁最后一个 ACK
4. 第四次挥手(ACK=1，seq=u+1,ack=w+1)，客户端➓收到来自服务器端✁关 闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待了某个固定时间（两 个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没 有收到服务器端✁ ACK ，认为服务器端已经正常关闭连➓，于✁自己也关闭连➓， 进入CLOSED 状态。服务器端➓收到这个确认包之后，关闭连➓，进入CLOSED 状态

## TCP 四次挥手过程中，为什么需要等待 2MSL,才进入 CLOSED 关闭状态
1. 1.为了保证客户端发送✁最后一个 ACK 报文段能够到达服务端。 这个 ACK 报 文段有可能丢失，因而使处在 LAST-ACK 状态✁服务端就收不到对已发送
2. 请求✲文段出现在本连➓中。客户端在发送完最后一个 ACK ✲文段后，再经过时间 2MSL，就可以使本连➓持续✁时间内所产生✁所有✲文段都从网络中✲失。这样就可以使下

## TCP的安全性
1. 首先，TCP✁连➓✁基于三次握手，而断开则✁基于四次挥手。确保连➓和断开✁ 可靠性
2. 其次，TCP ✁可靠性，还体现在有状态;TCP 会记录哪些数据发送了，哪些数据被 ➓收了，哪些没有被➓受，并且保证数据包按序到达，保证数据传输不出差错。
3. 再次，TCP ✁可靠性，还体现在可控制。它有数据包校验、ACK 应答、**超时重 传(发送方)**、失序数据重传（➓收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制
！[TCP信息](http://rvm97utlj.hn-bkt.clouddn.com/tcp%E4%BF%A1%E6%81%AF.png)

1. 16 位端口号：源端口号，主机该✲文段✁来自哪里；目标端口号，要传给哪个上 层协议或应用程序
2. 32 位序号：一次 TCP 通信（从 TCP 连➓✁立到断开）过程中某一个传输方向上 ✁字节流✁每个字节✁编号
3. 32 位确认号：用作对另一方发送✁ tcp ✲文段✁响应。其值✁收到✁ TCP ✲文段 ✁序号值加 1
4. 4 位头部长度：表示 tcp 头部有多少个 32bit 字（4 字节）。因为 4 位最大能标 识15，所以TCP头部最长✁ 60字节
5. 6 位标志位：URG(紧急指针✁否有效)，ACk（表示确认号✁否有效），PSH（缓 冲区尚未填满），RST（表示要求对方重新✁立连➓），SYN（✁立连➓✲息标志➓），FIN（表示告知对方本端要关闭连➓了）
6. 16 位窗口大小：✁ TCP 流量控制✁一个手段。这里说✁窗口，指✁✁➓收通告 窗口。它告诉对方本端✁ TCP➓收缓冲区还能容纳多少字节✁数据，这样对方就可以控制发送数据✁速度
7. 16 位校验和：由发送端填充，➓收端对 TCP ✲文段执行 CRC 算法以检验 TCP ✲文段在传输过程中✁否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也✁ TCP可靠传输✁一个重要保障
8. 16 位校验和：由发送端填充，➓收端对 TCP ✲文段执行 CRC 算法以检验 TCP ✲文段在传输过程中✁否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也✁ TCP可靠传输✁一个重要保障

## 聊聊 TCP ✁滑动窗口
1. TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样✁话 就会有个缺点：效率会比较低
2. 为了解决这个问题，TCP 引入了窗口，它✁操作系统开辟✁一个缓存空间。窗 口大小值表示无需等待确认应答，而可以继续发送数据✁最大值。 TCP 头部有个字段叫 win，也即那个 16 位✁窗口大小，它告方本端✁ TCP ➓收缓冲区还能容纳多少字节✁数据，这样对方就可以控制发送数据✁速度，从而达到流量控制✁目✁。

## 说说 TCP ✁流量控制
1. 假如当前发送方给➓收方发送了 200 个字节，那么，发送方✁ SND.NXT会右移 200 个字节，也就✁说当前✁可用窗口减少了 200 个字节
2. 受方收到后，放到缓冲队列里面，REV.WND =400-200=200 字节，所以 win=200 字节返回给发送方。➓收方会在 ACK ✁✲文首部带上缩小后✁滑动窗口200字节3. 发送方又发送 200 字节过来，
3. 200 字节到达，继续放到缓冲队列。不过这时候， 由于大量负载✁原因，➓受方处理不了这么多字节，只能处理 100 字节，剩余✁ 100 字节继续放到缓冲队列。这时候，REV.WND = 400-200-100=100 字节，即win=100返回发送方
4. 发送方继续干活，发送 100 字节过来，这时候，➓受窗口 win 变为 0
5. 发送方停止发送，开启一个定时任务，每隔一段时间，就去询问➓受方，直到 win 大于 0，才继续开始发送

## TCP ✁拥塞控制
1. 慢启动： 慢启动算法，表面意思就✁，别急慢慢来。它表示 TCP ✁立连➓完成后，一开 始不要发送大量✁数据，而✁先探测一下网络✁拥塞程度。由小到大逐渐增加 拥塞窗口✁大小，如果没有出现丢包，每收一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位✁ MSS）。每轮次发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段
2. 一般来说，慢启动阀值 ssthresh ✁ 65535 字节，cwnd到达慢启动阀值后
3. 快速恢复快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。正如前面所说，进入快速恢复之前，cwnd 和 sshthresh 已被更新

## cookie和session
1. 当通过浏览器进行网页访问的时候，服务器可以把某一些状态数据以key-value的方式写入到Cookie 里面存储到客户端浏览器。 然后客户端下一次再访问服务器的时候，就可以携带这些状态数据发送到服务器端，服务端可以根据Cookie里面携带的内容来识别使用者。
2. Session表示一个会话，它是属于服务器端的容器对象，默认情况下，针对每一个浏览器的请求。Servlet容器都会分配一个Session。
3. Session本质上是一个ConcurrentHashMap，可以存储当前会话产生的一些状态数据。 我们都知道，Http协议本身是一个无状态协议，也就是服务器并不知道客户端发送过来的多次请求是属于同一个用户
4. 客户端第一次访问服务端，服务端创建会话，将sessionid存储到cookie，服务端将sessionID识别会话状态。







