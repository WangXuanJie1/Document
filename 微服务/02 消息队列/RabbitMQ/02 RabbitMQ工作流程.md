#### 生产者发送消息的流程 
1. 生产者连接RabbitMQ，建立TCP连接( Connection)，开启信道（Channel） 2. 生产者声明一个Exchange（交换器），并设置相关属性，比如交换器类型、是否持久化等 3. 生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等 4. 生产者通过bindingKey（绑定Key）将交换器和队列绑定（binding）起来 5. 生产者发送消息至RabbitMQ Broker，其中包含routingKey（路由键）、交换器等信息 6. 相应的交换器根据接收到的routingKey查找相匹配的队列。 7. 如果找到，则将从生产者发送过来的消息存入相应的队列中。 8. 如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者 9. 关闭信道。
10. 关闭连接。

#### 消费者接收消息的过程 
1. 消费者连接到RabbitMQ Broker ，建立一个连接(Connection ) ，开启一个信道(Channel) 。 2. 消费者向RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数， 以及 做一些准备工作
3. 等待RabbitMQ Broker 回应并投递相应队列中的消息， 消费者接收消息。 4. 消费者确认( ack) 接收到的消息。 5. RabbitMQ 从队列中删除相应己经被确认的消息。 6. 关闭信道。
7. 关闭连接。

### Connection 和Channel关系
1. 生产者和消费者，需要与RabbitMQ Broker 建立TCP连接，也就是Connection 。
2. 一旦TCP 连接建 立起来，客户端紧接着创建一个AMQP 信道（Channel），每个信道都会被指派一个唯一的ID。信道是建立在Connection 之上的虚拟连接， RabbitMQ 处理的每条AMQP 指令都是通过信道完成的。
3. RabbitMQ 采用类似NIO的做法，复用TCP 连接，减少性能开销，便于管理。 当每个信道的流量不是很大时，复用单一的Connection 可以在产生性能瓶颈的情况下有效地节省TCP 连接资源。
4. 当信道本身的流量很大时，一个Connection 就会产生性能瓶颈，流量被限制。需要建立多个 Connection ，分摊信道。具体的调优看业务需要。信道在AMQP 中是一个很重要的概念，大多数操作都是在信道这个层面进行的。

### RabbitMQ工作模式详解
1. 生产者发消息，启动多个消费者实例来消费消息，每个消费者仅消费部分信息，可达到负载均衡的 效果。
2. 使用fanout类型交换器，routingKey忽略。每个消费者定义生成一个队列并绑定到同一个 Exchange，每个消费者都可以消费到完整的消息。消息广播给所有订阅该消息的消费者。
3. 实现RabbitMQ的消费者有两种模式，推模式（Push）和拉模式（Pull）。 实现推模式推荐的方式 是继承 DefaultConsumer 基类，也可以使用Spring AMQP的 SimpleMessageListenerContainer 。
4. 推 模式是最常用的，但是有些情况下推模式并不适用的，
5. 比如说： 由于某些限制，消费者在某个条件成立 时才能消费消息 需要批量拉取消息进行处理 实现拉模式 RabbitMQ的Channel提供了 basicGet 方法用于拉取消息。

### TTL机制（time to live）
1. 创建一个倒计时，指定时间内没有消费就默认订单取消
2. 通过Queue属性设置，队列中所有消息都有相同的过期时间。 2. 对消息自身进行单独设置，每条消息的TTL 可以不同。
3. 设置消息的过期时间

### 死信队列
1. 用户下单，调用订单服务，然后订单服务调用派单系统通知外卖人员送单，这时候订单系统与派单 系统 采用 MQ异步通讯。
2. 在定义业务队列时可以考虑指定一个 死信交换机，并绑定一个死信队列。当消息变成死信时，该消 息就会被发送到该死信队列上，这样方便我们查看消息失败的原因。
3. DLX，全称为Dead-Letter-Exchange，死信交换器。消息在一个队列中变成死信（Dead Letter） 之后，被重新发送到一个特殊的交换器（DLX）中，同时，绑定DLX的队列就称为“死信队列”。
4. 消息被拒绝（Basic.Reject/Basic.Nack），并且设置requeue参数为false；，消息过期，消息最大长度

### 延迟队列
1. 延迟消息是消息发送出去不想直接被消费，需要等待一段时间被消费
2. 可以使用rabbitmq_delayed_message_exchange插件实现。
3. 生产者将消息(msg)和路由键(routekey)发送指定的延时交换机(exchange)上
4. 延时交换机(exchange)存储消息等待消息到期根据路由键(routekey)找到绑定自己的队列 (queue)并把消息给它
5. 队列(queue)再把消息发送给监听它的消费者(customer）

### rabbitmq的主备模式
1. 也叫Warren（兔子窝）模式，同一时刻只有一个节点在工作（备份节点不能读写），当主节点发 生故障后会将请求切换到备份节点上（主恢复后成为备份节点）。需要借助HAProxy之类的（VIP模式）负载均衡器来做健康检查和主备切换，底层需要借助共享存储（如SAN设备）。
2. 前面我们讲了，RabbitMQ内置的集群模式有丢失消息的风险，“镜像队列”可以看成是对内置默认 集群模式的一种高可用架构的补充。可以将队列镜像（同步）到集群中的其他broker上，相当于是多副 本冗余。如果集群中的一个节点失效，队列能自动地切换到集群中的另一个镜像节点上以保证服务的可用性，而且消息不丢失。
3. 联邦模式： 无论是Federation还是Shovel都只是解决消息数据传输的问题（当然插件自身可能会一些应用层的 优化），跨机房跨城市的这种网络延迟问题是客观存在的，不是简单的通过什么插件可以解决的，一般需要借助昂贵的专线。
4. 

