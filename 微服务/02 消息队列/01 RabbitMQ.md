#### 消息中间件： 异步处理、流量削峰、限流、缓冲、排队、最终一致性、消
1. 优点：
  - 轻量级，快速，部署使用方便
  - 支持灵活的路由配置。RabbitMQ中，在生产者和队列之间有一个交换器模块。根据配置的路 由规则，生产者发送的消息可以发送到不同的队列中。路由规则很灵活，还可以自己实现。
  - RabbitMQ的客户端支持大多数的编程语言。
2. 缺点：
  - 如果有大量消息堆积在队列中，性能会急剧下降
  - RabbitMQ的性能在Kafka和RocketMQ中是最差的，每秒处理几万到几十万的消息。如果应 用要求高的性能，不要选择RabbitMQ。
  - RabbitMQ是Erlang开发的，功能扩展和二次开发代价很高。
  - 
#### RocketMQ RocketMQ是一个开源的消息队列，使用java实现。借鉴了Kafka的设计并做了很多改进。
1. RocketMQ主要用于有序，事务，流计算，消息推送，日志流处理，binlog分发等场景。经过了历次的 双11考验，性能，稳定性可可靠性没的说。
2. RocketMQ几乎具备了消息队列应该具备的所有特性和功能。 java开发，阅读源代码、扩展、二次开发很方便。
3. 对电商领域的响应延迟做了很多优化。在大多数情况下，响应在毫秒级。如果应用很关注响应时间，可以使用RocketMQ。 性能比RabbitMQ高一个数量级，每秒处理几十万的消息。
4. 缺点：跟周边系统的整合和兼容不是很好。

#### Kafka Kafka的可靠性，
1. 稳定性和功能特性基本满足大多数的应用场景。 跟周边系统的兼容性是数一数二的，尤其是大数据和流计算领域，几乎所有相关的开源软件都支持Kafka。
2. Kafka高效，可伸缩，消息持久化。支持分区、副本和容错。 Kafka是Scala和Java开发的，对批处理和异步处理做了大量的设计，因此Kafka可以得到非常高的 性能。它的异步消息的发送和接收是三个中最好的，但是跟RocketMQ拉不开数量级，每秒处理几十万 的消息。
3. 如果是异步消息，并且开启了压缩，Kafka最终可以达到每秒处理2000w消息的级别。 但是由于是异步的和批处理的，延迟也会高，不适合电商场景。

### 三者的比较
1. rabbit性能最低，消息延迟最低，主从架构。rocket主从架构，kafka分布式部署

### JMS规范和AMQP协议
1. JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间 件（MOM，Message oriented Middleware）的API，
2. 用于在两个应用程序之间，或分布式系统中发送 消息，进行异步通信。与具体平台无关的API，绝大多数MOM提供商都支持。
3. 它类似于JDBC(Java Database Connectivity)。消息是JMS中的一种类型对象，由两部分组成：报文头和消息主体
4. 模式：点对点模式，发布订阅模式

### 点对点模式
1. 在点对点或队列模型下 一个生产者向一个特定的队列发布消息，一个消费者从该队列中读取消息。
2. 这里，生产者知道消费 者的队列，并直接将消息发送到消费者的队列，概括为： 一条消息只有一个消费者获得生产者无需在接收者消费该消息期间处于运行状态，接收者也同样无需在消息发送时处于运行 状态。
3. 每一个成功处理的消息要么自动确认，要么由接收者手动确认。

### 发布订阅模式
1. 支持向一个特定的主题发布消息。 0或多个订阅者可能对接收特定消息主题的消息感兴趣。 发布者和订阅者彼此不知道对方。
2. 多个消费者可以获得消息在发布者和订阅者之间存在时间依赖性。 发布者需要建立一个主题，以便客户能够订阅。
3. 订阅者必须保持持续的活动状态以接收消息，否则会丢失未上线时的消息。
4. 对于持久订阅，订阅者未连接时发布的消息将在订阅者重连时重发。

### AMQP中的概念
1. Publisher：消息发送者，将消息发送到Exchange并指定RoutingKey，以便queue可以接收到指 定的消息。
2.  Consumer：消息消费者，从queue获取消息，一个Consumer可以订阅多个queue以从多个 queue中接收消息。
3.  Server：一个具体的MQ服务实例，也称为Broker。
4.  Virtual host：虚拟主机，一个Server下可以有多个虚拟主机，用于隔离不同项目，一个Virtualhost通常包含多个Exchange、Message Queue。
5.  Exchange：交换器，接收Producer发送来的消息，把消息转发到对应的Message Queue中。
6.  Routing key：路由键，用于指定消息路由规则（Exchange将消息路由到具体的queue中），通常需要和具体的Exchange类型、Binding的Routing key结合起来使用。
7.  Bindings：指定了Exchange和Queue之间的绑定关系。Exchange根据消息的Routing key和 Binding配置（绑定关系、Binding、Routing key等）来决定把消息分派到哪些具体的queue中。这依 赖于Exchange类型。
8.  Message Queue：实际存储消息的容器，并把消息传递给最终的Consumer。

### AMQP 使用的数据类型如下： 
1. Integers（数值范围1-8的十进制数字）：用于表示大小，数量，限制等，整数类型无符号 的，可以在帧内不对齐。
2. Bits（统一为8个字节）：用于表示开/关值。
3. Short strings：用于保存简短的文本属性，字符串个数限制为255，8个字节
4. Long strings：用于保存二进制数据块。
5. Field tables：包含键值对，字段值一般为字符串，整数等

### Exchange类型
1. RabbitMQ常用的交换器类型有：fanout、direct、topic、headers四种。这是一个关于消息传递中的Exchange类型的问题。在AMQP（高级消息队列协议）中，有四种常见的Exchange类型：fanout、direct、topic和headers。
1. Fanout Exchange（扇出交换机）：它将消息广播到与该Exchange绑定的所有队列。它不考虑路由键，只需简单地将消息发送到与该Exchange绑定的所有队列。这是一种一对多的模式。
2. Direct Exchange（直连交换机）：它根据消息的路由键将消息发送到与该键完全匹配的队列。它是一种一对一的模式。
3. Topic Exchange（主题交换机）：它根据消息的路由键模式将消息发送到与该模式匹配的队列。它是一种灵活的模式匹配方式，可以实现一对多或多对多的模式。
4. Headers Exchange（头交换机）：它根据消息的头部属性进行匹配，并将消息发送到与匹配条件匹配的队列。它不考虑路由键，可以实现高级的匹配规则。
5. 这些Exchange类型在消息传递中具有不同的用途和特性，可以根据实际需求选择合适的类型来实现消息的传递和路由。

###  RabbitMQ数据存储
1. abbitMQ消息有两种类型： 1. 持久化消息和非持久化消息。 2. 这两种消息都会被写入磁盘。
2. 持久化消息在到达队列时写入磁盘，同时会内存中保存一份备份，当内存吃紧时，消息从内存中清 除。这会提高一定的性能。
3. 非持久化消息一般只存于内存中，当内存压力大时数据刷盘处理，以节省内存空间。RabbitMQ存储层包含两个部分：队列索引和消息存储。
4. 队列索引：rabbit_queue_index 索引维护队列的落盘消息的信息，如存储地点、是否已被给消费者接收、是否已被消费者ack等。每个队列都有相对应的索引。
    - 索引引使用顺序的段文件来存储，后缀为.idx，文件名从0开始累加，每个段文件中包含固定的 segment_entry_count条记录，默认值是16384。</br>
      每个index从磁盘中读取消息的时候，至少要在内存 中维护一个段文件，所以设置queue_index_embed_msgs_below值得时候要格外谨慎，一点点增大也可能会引起内存爆炸式增长。
5. 消息存储：rabbit_msg_store，
    - 消息以键值对的形式存储到文件中，一个虚拟主机上的所有队列使用同一块存储，每个节点只有一 个。存储分为持久化存储（msg_store_persistent）和短暂存储（msg_store_transient）。</br>
      持久化存 储的内容在broker重启后不会丢失，短暂存储的内容在broker重启后丢失。</br>
      store使用文件来存储，后缀为.rdq，经过store处理的所有消息都会以追加的方式写入到该文件 中，当该文件的大小超过指定的限制（file_size_limit）后，将会关闭该文件并创建一个新的文件以供新的消息写入。</br>
      文件名从0开始进行累加。在进行消息的存储时，RabbitMQ会在ETS（Erlang TermStorage）表中记录消息在文件中的位置映射和文件的相关信息。
6. 消息（包括消息头、消息体、属性）可以直接存储在index中，也可以存储在store中。最佳的方式 是较小的消息存在index中，而较大的消息存在store中。这个消息大小的界定可以通过 queue_index_embed_msgs_below来配置，
   - 默认值为4096B。当一个消息小于设定的大小阈值时，就 可以存储在index中，这样性能上可以得到优化。一个完整的消息大小小于这个值，就放到索引中，否则放到持久化消息文件中。
7. 读取消息时，先根据消息的ID（msg_id）找到对应存储的文件，如果文件存在并且未被锁住，则直 接打开文件，从指定位置读取消息内容。如果文件不存在或者被锁住了，则发送请求由store进行处 理。
8. 删除消息时，只是从ETS表删除指定消息的相关信息，同时更新消息对应的存储文件和相关信息。 在执行消息删除操作时，并不立即对文件中的消息进行删除，也就是说消息依然在文件中，仅仅是标记 为垃圾数据而已。
   - 当一个文件中都是垃圾数据时可以将这个文件删除。当检测到前后两个文件中的有效 数据可以合并成一个文件，并且所有的垃圾数据的大小和所有文件（至少有3个文件存在的情况下）的数据大小的比值超过设置的阈值garbage_fraction（默认值0.5）时，才会触发垃圾回收，将这两个文件 合并，执行合并的两个文件一定是逻辑上相邻的两个文件。
   - 合并逻辑： 1. 锁定这两个文件 2. 先整理前面的文件的有效数据，再整理后面的文件的有效数据将后面文件的有效数据写入到前面的文件中
#### rabbit_variable_queue.erl源码中定义了RabbitMQ队列的4种状态： 
1. alpha：消息索引和消息内容都存内存，最耗内存，很少消耗CPU
2. beta：消息索引存内存，消息内存存磁盘
3. gama：消息索引内存和磁盘都有，消息内容存磁盘
4. delta：消息索引和内容都存磁盘，基本不消耗内存，消耗更多CPU和I/O操作
5. 消息存入队列后，不是固定不变的，它会随着系统的负载在队列中不断流动，消息的状态会不断发 送变化。
6. 持久化的消息，索引和内容都必须先保存在磁盘上，才会处于上述状态中的一种 gama状态只有持久化消息才会有的状态。
   在运行时，RabbitMQ会根据消息传递的速度定期计算一个当前内存中能够保存的最大消息数量
（target_ram_count），如果alpha状态的消息数量大于此值，则会引起消息的状态转换，多余的消息
可能会转换到beta、gama或者delta状态。区分这4种状态的主要作用是满足不同的内存和CPU需求。

  ### 队列结构
  1. 通常队列由rabbit_amqqueue_process和backing_queue这两部分组成， rabbit_amqqueue_process负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息处理消息的确认（包括生产端的confirm和消费端的ack）等。
  2. backing_queue是消息存储的具体形式和引擎，并向rabbit_amqqueue_process提供相关的接口以供调用。
  3. 如果消息投递的目的队列是空的，并且有消费者订阅了这个队列，那么该消息会直接发送给消费 者，不会经过队列这一步。当消息无法直接投递给消费者时，需要暂时将消息存入队列，以便重新投递
  4. 
